#+startup: overview
#+title: Emacs Config File
#+author: Kaushik Skye Harith
#+email: skye.harith@gmail.com
#+options: toc:t todo:nil

* User Information
This contains basic user information regarding the user such as email id and name. It is used throughout emacs in places such as Org mode preambles and Mu4e.

#+begin_src emacs-lisp
  ;; -*- lexical-binding: t -*-
    (setq user-full-name "Kaushik Srinivasan Harith")
    (setq user-mail-address "kaushik@archeanchemicals.com")
#+end_src

* Tweaks to emacs' functioning
This is a list of non-cosmetic changes to the way emacs naturally functions. 

** Better autosaving
Auto-saving for default emacs puts the auto saved files in the current working directory. I like having it in a seperate folder. This also maintains more new versions and fewer old versions from the point of file save. 

#+begin_src emacs-lisp
  (setq backup-by-copying t      ; don't clobber symlinks
        backup-directory-alist '(("." . "~/.emacs.d/saves/"))    ; don't litter my fs tree
        delete-old-versions t
        kept-new-versions 6
        kept-old-versions 2
        version-control t)       ; use versioned backups

  (setq auto-save-file-name-transforms
        `((".*" "~/.emacs.d/saves/" t)))
#+end_src

** Vertical splits as defualt
For reasons beyond my knowledge, emacs chooses to split new windows length-wise instead of breadth-wise. 

#+begin_src emacs-lisp
  (setq split-height-threshold nil) ;window.el
  (setq split-width-threshold 0) ;window.el
#+end_src

** Window Management
Emacs places windows way too inconsistently. This fixes that. Stoled from Protesilaos' config.

#+begin_src emacs-lisp
  (use-package window
    :straight nil
    :init
    (setq display-buffer-alist
	  '(;; top side window
	    ("\\*\\(Flycheck\\|Flymake\\|Package-Lint\\|vc-git :\\).*" ;; This bit is useless to me currently. Rethink it later. 
	     (display-buffer-in-side-window)
	     (window-height . 0.25)
	     (side . top)
	     (slot . 0))
	    ("\\*Messages.*"
	     (display-buffer-in-side-window)
	     (window-height . 0.25)
	     (side . top)
	     (slot . 1))
	    ("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\)\\*"
	     (display-buffer-in-side-window)
	     (window-height . 0.25)
	     (side . top)
	     (slot . 2))
	    ;; bottom side window
	    ("\\*\\(Output\\|Register Preview\\).*"
	     (display-buffer-in-side-window)
	     (window-width . 0.20)       ; See the :hook
	     (side . bottom)
	     (slot . -1))
	    (".*\\*\\(Completions\\|Embark.*Occur\\).*"
	     (display-buffer-in-side-window)
	     (window-height . 0.25)
	     (side . bottom)
	     (slot . 0))
	    ("^\\(\\*e?shell\\|vterm\\).*" ;; You don't use eshell. get rid of it
	     (display-buffer-in-side-window)
	     (window-width . 0.40)
	     (side . bottom)
	     (slot . 1))
	    ;; left side window
	    ("\\*Help.*"
	     (display-buffer-in-side-window)
	     (window-width . 0.25)       ; See the :hook
	     (side . left)
	     (slot . 0))
	    ;; right side window
	    ("\\*Faces\\*"
	     (display-buffer-in-side-window)
	     (window-width . 0.25)
	     (side . right)
	     (slot . 0)
	     (window-parameters . ((mode-line-format . (" " mode-line-buffer-identification)))))
	    ("\\*Custom.*"
	     (display-buffer-in-side-window)
	     (window-width . 0.25)
	     (side . right)
	     (slot . 1))
	    ;; bottom buffer (NOT side window)
	    ("\\*\\vc-\\(incoming\\|outgoing\\).*"
	     (display-buffer-at-bottom))))
    (setq window-combination-resize t)
    (setq even-window-sizes 'height-only)
    (setq window-sides-vertical nil)
    ;; Note that the the syntax for `use-package' hooks is controlled by
    ;; the `use-package-hook-name-suffix' variable.  The "-hook" suffix is
    ;; not an error of mine.
    :hook ((help-mode . visual-line-mode)
	   (custom-mode . visual-line-mode))
    :bind (("s-n" . next-buffer)
	   ("s-p" . previous-buffer)
	   ("s-o" . other-window)
	   ("s-0" . delete-window)
	   ("s-1" . delete-other-windows)
	   ("s-5" . delete-frame)
	   ("C-x +" . balance-windows-area)))
#+end_src

** Custom-set variables get their own file
I like a clean init.el. Custom-set variables getting thrown in init.el isn't my favourite thing. The solution is to put it in its own file lol. Laziness is always the best solution.

#+begin_src emacs-lisp
  (setq custom-file (concat user-emacs-directory "custom.el"))

  (load-file custom-file)
#+end_src

** Misc

#+begin_src emacs-lisp
  (global-visual-line-mode t)

  (setq initial-major-mode 'org-mode)
  (setq default-major-mode 'org-mode)
#+end_src

* Tweaks to emacs' appearance
** Nano stuff
Nano emacs is a nifty collection of vanilla esque presets for emacs. I have merged some of those things into my own config.

*** Basics
Some simple stuff

#+begin_src emacs-lisp
  (straight-use-package
   '(nano-emacs :type git :host github :repo "rougier/nano-emacs"))

  (require 'nano-faces)

  (require 'nano-layout)
  (window-divider-mode 0)

  (require 'nano-defaults)

  (require 'nano-session)
#+end_src

*** COMMENT Modeline
Nano modeline mode from repo is not used because it doesn't support themeing of faces

#+begin_src emacs-lisp
  (use-package nano-modeline
    :straight (:type git :host github :repo "rougier/nano-modeline")
    :config
    (add-hook 'prog-mode-hook            #'nano-modeline-prog-mode)
    (add-hook 'text-mode-hook            #'nano-modeline-text-mode)
    (add-hook 'org-mode-hook             #'nano-modeline-org-mode)
    (add-hook 'pdf-view-mode-hook        #'nano-modeline-pdf-mode)
    (add-hook 'mu4e-headers-mode-hook    #'nano-modeline-mu4e-headers-mode)
    (add-hook 'mu4e-view-mode-hook       #'nano-modeline-mu4e-message-mode)
    (add-hook 'elfeed-show-mode-hook     #'nano-modeline-elfeed-entry-mode)
    (add-hook 'elfeed-search-mode-hook   #'nano-modeline-elfeed-search-mode)
    (add-hook 'term-mode-hook            #'nano-modeline-term-mode)
    (add-hook 'xwidget-webkit-mode-hook  #'nano-modeline-xwidget-mode)
    (add-hook 'messages-buffer-mode-hook #'nano-modeline-message-mode)
    (add-hook 'org-capture-mode-hook     #'nano-modeline-org-capture-mode)
    (add-hook 'org-agenda-mode-hook      #'nano-modeline-org-agenda-mode))
#+end_src

** Font and font size

#+begin_src emacs-lisp
  (set-face-attribute 'default nil :font "Dejavu Sans Mono" :height 130)
#+end_src

** COMMENT TransSide theme
This is my own custom theme based on the colors of the trans flag. Pink and Blue are regularly used as highlight and accent colors with purple/lavenders acting as a unifying inbetween.

#+begin_src emacs-lisp
  (use-package TransSide
    :straight (TransSide :type git :host github :repo "Harith163/TransSide-theme")
    :config
    (load-theme 'TransSide-dark t))
#+end_src

** Adwaita Theme
#+begin_src emacs-lisp
  (use-package modus-themes
    :config
    (load-theme 'modus-vivendi 1))
#+end_src

** Modeline
#+begin_src emacs-lisp
  (use-package simple-modeline
    :hook (after-init . simple-modeline-mode))
#+end_src

** Transparency
#+begin_src emacs-lisp
   (set-frame-parameter (selected-frame) 'alpha '(98 . 50))
   (add-to-list 'default-frame-alist '(alpha . (98 . 50)))
#+end_src

* Custom functions
This is a catch all place to dump custom functions. 

** Intelligent minibuffer quits
Quitting out of the minibuffer can be a bit finicky. This function forces focus to the minibuffer when it is "active". For the time being, I also remap C-g here. To be refiled.

#+begin_src emacs-lisp
  (defun contrib/keyboard-quit-context+ ()
    "Quit current context.

  This function is a combination of `keyboard-quit' and
  `keyboard-escape-quit' with some parts omitted and some custom
  behavior added."
    (interactive)
    (cond ((region-active-p)
           ;; Avoid adding the region to the window selection.
           (setq saved-region-selection nil)
           (let (select-active-regions)
             (deactivate-mark)))
          ((eq last-command 'mode-exited) nil)
          (current-prefix-arg
           nil)
          (defining-kbd-macro
            (message
             (substitute-command-keys
              "Quit is ignored during macro defintion, use \\[kmacro-end-macro] if you want to stop macro definition"))
            (cancel-kbd-macro-events))
          ((active-minibuffer-window)
           (when (get-buffer-window "*Completions*")
             ;; hide completions first so point stays in active window when
             ;; outside the minibuffer
             (minibuffer-hide-completions))
           (abort-recursive-edit))
          (t
           (when completion-in-region-mode
             (completion-in-region-mode -1))
           (let ((debug-on-quit nil))
             (signal 'quit nil)))))

  (global-set-key [remap keyboard-quit] #'contrib/keyboard-quit-context+)
#+end_src

** Kill current buffer 
A mini function that I use for my own quick quit for things like ibuffer etc.

#+begin_src emacs-lisp
  (defun skye/kill-current-buffer ()
    (interactive)
    (kill-buffer (current-buffer)))
#+end_src

** Buffer scale
Self explanatory, to change buffer text size.

#+begin_src emacs-lisp
  (defun skye/small-text-scale ()
    "Make the buffer text zoom smaller"
    (interactive)
    (text-scale-set -1))

  (defun skye/big-text-scale ()
    "Make the buffer text zoom bigger"
    (interactive)
    (text-scale-set 1))
#+end_src

** Kill window on quit buffer
Usefull for things like dired, ibuffer etc that don't kill the window on quitting.

#+begin_src emacs-lisp
  (defun skye/quit-window ()
    "If more than one window is open, close window on quit"
    (interactive)
    (if (> (length (window-list)) 1) (delete-window) (quit-window)))
#+end_src

** Reload theme

#+begin_src emacs-lisp
  (defun skye/reload-theme ()
    "Reload a theme by disabling that theme first"
    (interactive)
    (let ((theme-name (split-string (buffer-name) "-")))
      (let ((theme (car (read-from-string (concat (car theme-name) "-" (car (cdr theme-name)))))))
    (eval-buffer (current-buffer))
    (disable-theme theme)
    (enable-theme theme))))
#+end_src

* Custom Keybinds
This is a list of custom keybinds that I couldn't fit in with the package declarations. Use "C-z" for all my custom keybinds and use "M-z" for functions that are related but broader/inverse in scope. Use the super key for things that are commonly associated with the "C-x C-" keybind.

The following functions are bound
  - remove redundant white space between text
  - evalueate top-level function instead of function at point (elisp/global)
  - a custom function to toggle window split from horizontal to vertical.
  - revert buffer 
  - comment and uncoment region.
  - Describe the face at point. Prefixed with Ctrl-z to distinguish between this and describe-function

#+begin_src emacs-lisp
  (use-package emacs
    :straight nil
    :bind
    (:map global-map
	  :prefix-map my-ctrl-z-prefix-map
	  :prefix "C-z"
	  ("C-<SPC>" . fixup-whitespace)
	  ("C-e" . eval-defun)
	  (";" . comment-region)
	  ("C-h f" . describe-face))

    (:map global-map
	  :prefix-map my-meta-z-prefix-map
	  :prefix "M-z"
	  (";" . uncomment-region))

    (:map global-map
	  ("<f5>" . revert-buffer)
	  ([remap kill-buffer] . skye/kill-current-buffer)
	  ("<f4>" . skye/reload-theme)
	  )
    ) 
#+end_src

* Packages
** Packages that make navigating emacs easier
*** All the icons 
All-the-icons provides fancy icons for all the lists and menus in emacs, but requires some setup in the form of font installlation.

**** All the icons

#+begin_src emacs-lisp
  (use-package all-the-icons)
#+end_src

**** All the icons for dired

#+begin_src emacs-lisp
  (use-package all-the-icons-dired)
#+end_src

**** All the icons for completions

#+begin_src emacs-lisp
  (use-package all-the-icons-completion)
#+end_src

*** CdLaTeX

#+begin_src emacs-lisp
  (use-package cdlatex)
#+end_src

*** Completion Stuff

#+begin_src emacs-lisp
  (use-package vertico
    :straight (vertico :files (:defaults "extensions/*")
                       :includes (vertico-indexed
                                  vertico-flat
                                  vertico-grid
                                  vertico-mouse
                                  vertico-quick
                                  vertico-buffer
                                  vertico-repeat
                                  vertico-reverse
                                  vertico-directory
                                  vertico-multiform
                                  vertico-unobtrusive
                                  ))
    :bind
    (:map vertico-map
          ("C-g" . contrib/keyboard-quit-context+)
          ("C-M-n" . vertico-next-group)
          ("C-M-p" . vertico-previous-group))
    :custom
    (vertico-count 8)                    ; Number of candidates to display
    (vertico-resize t)
    (vertico-cycle nil) ; Go from last to first candidate and first to last (cycle)?
    :init
    (vertico-mode)
    )

  (use-package marginalia
    :custom
    (marginalia-max-relative-age 0)
    (marginalia-align 'right)
    :init
    (marginalia-mode))

  (use-package consult
    :bind
    (:map global-map
          ("C-s" . consult-line)
          ("C-x b" . consult-buffer)
       ))

  (use-package savehist
    :config (savehist-mode))
#+end_src

*** Corfu
#+begin_src emacs-lisp
  (use-package corfu
    :config
    (setq corfu-auto t)
    (setq corfu-auto-delay 0)
    (setq corfu-auto-prefix 0)
    (setq corfu-quit-no-match t)
    :init
    (global-corfu-mode))

  (use-package cape
    ;; Bind dedicated completion commands
    ;; Alternative prefix keys: C-c p, M-p, M-+, ...
    :bind (("C-c p p" . completion-at-point) ;; capf
           ("C-c p t" . complete-tag)        ;; etags
           ("C-c p d" . cape-dabbrev)        ;; or dabbrev-completion
           ("C-c p h" . cape-history)
           ("C-c p f" . cape-file)
           ("C-c p k" . cape-keyword)
           ("C-c p s" . cape-symbol)
           ("C-c p a" . cape-abbrev)
           ("C-c p i" . cape-ispell)
           ("C-c p w" . cape-dict)
           ("C-c p \\" . cape-tex)
           ("C-c p _" . cape-tex)
           ("C-c p ^" . cape-tex)
           ("C-c p &" . cape-sgml)
           ("C-c p r" . cape-rfc1345))
    :init
    ;; Add `completion-at-point-functions', used by `completion-at-point'.
    (add-to-list 'completion-at-point-functions #'cape-dabbrev)
    (add-to-list 'completion-at-point-functions #'cape-file)
    (add-to-list 'completion-at-point-functions #'cape-keyword)
    (add-to-list 'completion-at-point-functions #'cape-tex)
    (add-to-list 'completion-at-point-functions #'cape-sgml)
    (add-to-list 'completion-at-point-functions #'cape-rfc1345)
    (add-to-list 'completion-at-point-functions #'cape-abbrev)
    (add-to-list 'completion-at-point-functions #'cape-ispell)
    (add-to-list 'completion-at-point-functions #'cape-dict)
    (add-to-list 'completion-at-point-functions #'cape-symbol)
  )
#+end_src

*** Dired
Dired or Dir-ed is the built in directory editor for emacs. Since it treats every thing as a text buffer, there are some powerful things we can do with it. I'm not smart enough to use it to its potential.

#+begin_src emacs-lisp
  (use-package dired
    :straight nil
    :config
    (setq dired-recursive-copies 'always)
    (setq dired-recursive-deletes 'always)
    (setq delete-by-moving-to-trash t)
    (setq dired-listing-switches "-al --group-directories-first --time-style=iso")
    (setq dired-dwim-target t)
    :hook
    ((dired-mode . dired-hide-details-mode)
     (dired-mode . all-the-icons-dired-mode))
    :bind
    (:map dired-mode-map ("q" . skye/quit-window)))
#+end_src

*** Electric pair mode
Common things that come in pairs are forced to exist in pairs. Part of vanilla emacs. Small change made in org mode to ignore <> completion.

#+begin_src emacs-lisp
  (use-package elec-pair
    :straight nil
    :hook
    (org-mode . (lambda ()
		  (setq-local electric-pair-inhibit-predicate
			      `(lambda (c)
				 (if (char-equal c ?<) t (,electric-pair-inhibit-predicate c))))))

    (org-mode . (lambda ()
		  (setq-local electric-pair-pairs (append electric-pair-pairs '((?$ . ?$))))))
    :config
    (electric-pair-mode 1))
#+end_src

*** Embark

#+begin_src emacs-lisp
  (use-package embark
    :bind
    (("C-." . embark-act)         ;; pick some comfortable binding
     ("C-;" . embark-dwim)        ;; good alternative: M-.
     ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

    :init
    (setq prefix-help-command #'embark-prefix-help-command)
    (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)

    :config
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))

  (use-package embark-consult
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

*** Expand-region
This changes the default mark position behaviour. Now, pressing ctrl-= after setting a mark will intelligently expand the highlighted region.

#+begin_src emacs-lisp
  (use-package expand-region
    :after (org)
    :bind
    (:map global-map
          ("C-=" . er/expand-region)))
#+end_src

*** Magit
Use git from within emacs!! Magit is the reason i don't use git from CLI anymore

#+begin_src emacs-lisp
  (use-package magit)
#+end_src

*** Quickly jump around -
Using letters from the home row to quickly navigate to a point on the screen. Much quicker than getting there with the cursor but uses brain power instead. Meh

**** Ace-Window

#+begin_src emacs-lisp
  (use-package ace-window
    :bind
    ([remap other-window] . ace-window)
    :config
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    )
#+end_src

**** Avy

#+begin_src emacs-lisp
  (use-package avy
    :bind
    (:map global-map
          ("C-;" . avy-goto-char)
          ("C-'" . avy-goto-char-2)
          ("M-g l" . avy-goto-line)
          ("M-g r" . avy-resume)
          :map org-mode-map
          ("C-'" . avy-goto-char-2))
    )
#+end_src

*** Rainbow delimiters
Delimiters is a fancy word/way of saying brackets, parenthesis, curly brackets etc. My personal favourite mini package maybe second to rainbow mode.

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :hook
    (prog-mode . rainbow-delimiters-mode)
    (Latex-mode . rainbow-delimiters-mode)
    :config
    (rainbow-delimiters-mode 1))
#+end_src

*** Rainbow mode
Turns any hex color code that appears in a file into the actual color it represents!!

#+begin_src emacs-lisp
  (use-package rainbow-mode)
#+end_src

*** Restart emacs from within emacs 
This is the quickest and the best thing ever for people who constantly change their mind/fuck things up (a.k.a me)
    
#+begin_src emacs-lisp
  (use-package restart-emacs
    :config
    (setq restart-emacs-restore-frames t))
#+end_src
    
*** Undo tree
This replaces the default undo behaviour in emacs and gives you a nice tree timeline to navigate. Standard ctrl-/ and ctrl-shift-/ with a tree given by ctrl-x u. q to quit and choose.

#+begin_src emacs-lisp
  (use-package undo-tree
    :init
    (global-undo-tree-mode)
    :config
    (setq undo-tree-history-directory-alist '(("." . "~/.emacs.d/undo"))))
#+end_src 

*** Which-Key
Provides completion for keybinds in the minibuffer. Its great.

#+begin_src emacs-lisp
  (use-package which-key
    :config (which-key-mode))
#+end_src

*** Yuck Mode
#+begin_src emacs-lisp
  (use-package yuck-mode)
#+end_src

** Packages that make me want to use emacs
These are the packages that drive my day to day use of emacs.

*** Languages
**** Language Server Protocol
#+begin_src emacs-lisp
  (use-package lsp-ltex
    :hook (text-mode . (lambda ()
                         (require 'lsp-ltex)
                         (lsp)))  ; or lsp-deferred
    :init
    (setq lsp-ltex-version "16.0.0"))
#+end_src
**** Rust mode
#+begin_src emacs-lisp
  (use-package rust-mode)
#+end_src
*** Org mode stuff
**** Org mode
EVERYTHING IN ORG MODE!!

#+begin_src emacs-lisp
  (use-package org
    :hook
    (org-mode . org-cdlatex-mode)
    (org-mode . org-indent-mode)

    :init
    (setq org-highlight-latex-and-related '(native latex script))
    (setq org-export-backends '(ascii html icalendar latex odt org))

    :bind
    (:map org-mode-map
      ("C-c C-x C-e" . skye/org-mark-and-archive)
      ("C-c C-x <up>" . org-cycle-list-bullet)
      :map global-map
      ("C-c a" . org-agenda)
      ("C-c c" . org-capture))

    :config
    (require 'org-tempo)

    (setq org-directory "~/Dropbox/Org/Daily")

    (defun skye/org-get-path (stringname)
      "Use concat to generate full path."
      (concat (file-name-as-directory org-directory) stringname))

    (setq skye/Readme (skye/org-get-path "Task List.org"))
    (setq skye/archive (skye/org-get-path "archive.org"))

    (setq org-agenda-files (list skye/Readme))
    (setq org-archive-location (concat skye/archive "::* From %s"))

    (setq org-ellipsis " ▼")
    (setq org-src-fontify-natively t)
    (setq org-src-tab-acts-natively t)

    (setq org-todo-keywords '((sequence "TODO(t)" "|" "Doing(i!)" "|" "Waiting(w!)") (sequence "|" "CANCELLED(c)" "|" "DONE(d)")))

    (setq org-enforce-todo-dependencies t)
    (setq org-enforce-todo-checkbox-dependencies t)

    (setq skye/bullets-list '("◉" "●" "○" "⊙"))

    (setq org-src-window-setup 'current-window)

    (defun skye/org-mark-and-archive ()
      "Mark the state of the current subtree as either DONE or CANCELLED and export to my archive.org file"
      (interactive)
      (org-todo (completing-read "Choose a final TODO state" '("DONE" "CANCELLED")))
      (org-archive-subtree))


    (setq org-pretty-entities nil)
    (setq org-preview-latex-default-process 'dvisvgm)

    (setq org-fontify-todo-headline t)
    (setq org-fontify-done-headline t)
    )
#+end_src
**** Org-modern
#+begin_src emacs-lisp
  (use-package org-modern
    :config
    (global-org-modern-mode))
#+end_src

*** EAF
Emacs application framework basically gives you a way to run javascript in emacs. I like the pdf reader but that is it.

#+begin_src emacs-lisp
  (use-package eaf
    :defer t
    :straight (emacs-application-framework :type git :host github :repo "emacs-eaf/emacs-application-framework")
    :load-path "~/.emacs.d/straight/repos/emacs-application-framework/"
    :custom
    ; See https://github.com/emacs-eaf/emacs-application-framework/wiki/Customization
    (eaf-browser-continue-where-left-off t)
    (eaf-browser-enable-adblocker t)
    (browse-url-browser-function 'eaf-open-browser)
    :config
    (require 'eaf-browser)
    (require 'eaf-pdf-viewer))
#+end_src

* Lastly
Things that are to be done at the end. This should only load if everything else doesn't fail. Should consider putting some of this in a different place.

#+begin_src emacs-lisp
  (put 'scroll-left 'disabled nil)
  (put 'dired-find-alternate-file 'disabled nil)
  (put 'narrow-to-region 'disabled nil)

  (setq font-lock-maximum-decoration t)
    (use-package orderless
    :custom
    (completion-styles '(orderless))      ; Use orderless
    (completion-category-defaults nil)    ; I want to be in control!
    (orderless-matching-styles
     '(orderless-literal
       orderless-prefixes
       orderless-initialism
       orderless-regexp
       )))
#+end_src  

** COMMENT Matu-gen theme
#+begin_src emacs-lisp
  (use-package f)
  (use-package s)
  (use-package autothemer)

  (load-file "~/.emacs.d/testing/matu-theme.el")
  (load-file "~/.emacs.d/testing/matu-gen-theme.el")
  (load-theme 'matu-gen 1)
#+end_src
